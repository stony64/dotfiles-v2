#!/usr/bin/env bash
#
# ┌───────────────────────────────────────────────────────────────────────────┐
# │ FILE: home/.bashfunctions                                                 │
# │ ZWECK: Sammlung nützlicher Shell-Funktionen (Linux & Windows)             │
# │ STANDARDS: Bash >= 4.0, Modulares Design, Google Shell Style Guide        │
# └───────────────────────────────────────────────────────────────────────────┘

# ──────────────────────────────────────────────────────────────
# 1. SUCHE & FINDEN
# ──────────────────────────────────────────────────────────────

# @description Schnelle Dateisuche im aktuellen Verzeichnis (case-insensitive).
f() {
    [[ $# -eq 0 ]] && { echo "Nutzung: f <dateiname>"; return 1; }
    find . -type f -iname "*$1*"
}

# @description Rekursive Textsuche in Dateien, ignoriert Binärdaten.
grepr() {
    [[ $# -eq 0 ]] && { echo "Nutzung: grepr <suchbegriff>"; return 1; }
    grep -rnI --color=always "$1" .
}

# ──────────────────────────────────────────────────────────────
# 2. ARCHIVIERUNG & EXTRAKTION
# ──────────────────────────────────────────────────────────────

# @description Intelligentes Entpacken verschiedenster Archivtypen.
extract() {
    local file="$1"
    [[ -z "$file" ]] && { echo "Keine Datei angegeben."; return 1; }
    [[ ! -f "$file" ]] && { echo "'$file' ist keine gültige Datei."; return 1; }

    case "$file" in
        *.tar.bz2|*.tbz2) tar xjf "$file"    ;;
        *.tar.gz|*.tgz)   tar xzf "$file"    ;;
        *.bz2)            bunzip2 "$file"    ;;
        *.rar)            unrar x "$file"    ;;
        *.gz)             gunzip "$file"     ;;
        *.tar)            tar xf "$file"     ;;
        *.zip)            unzip "$file"      ;;
        *.Z)              uncompress "$file" ;;
        *.7z)             7z x "$file"       ;;
        *)                echo "Fehler: '$file' Format nicht unterstützt." ; return 1 ;;
    esac
}

# ──────────────────────────────────────────────────────────────
# 3. NETZWERK & DIAGNOSE
# ──────────────────────────────────────────────────────────────

# @description Zeigt lokale und öffentliche IP-Adressen.
myip() {
    echo -e "${UI_ATTR_BOLD:-}Netzwerk-Status:${UI_COL_RESET:-}"

    # Lokale IP
    echo -n "  Lokale IP:  "
    if [[ "${PLATFORM:-}" == "linux" ]]; then
        hostname -I 2>/dev/null | awk '{print $1}' || hostname -i
    elif [[ "${PLATFORM:-}" == "windows" ]]; then
        ipconfig | grep -i "IPv4" | awk -F: '{ print $2 }' | head -n 1 | sed 's/^[ \t]*//'
    fi

    # Öffentliche IP
    if command -v curl >/dev/null 2>&1; then
        echo -n "  Öffentlich: "
        local pub_ip
        pub_ip=$(curl -s --connect-timeout 3 https://ifconfig.me)
        echo "${pub_ip:-Nicht erreichbar}"
    fi
}

# ──────────────────────────────────────────────────────────────
# 4. PLATTFORM-SPEZIFISCHE HELFER
# ──────────────────────────────────────────────────────────────

if [[ "${PLATFORM:-}" == "linux" ]]; then
    # Top-Prozesse nach Speicher
    top_mem() { ps auxf | sort -nr -k 4 | head -n 10; }
    # Top-Prozesse nach CPU
    top_cpu() { ps auxf | sort -nr -k 3 | head -n 10; }

elif [[ "${PLATFORM:-}" == "windows" ]]; then
    # @description Wandelt Windows-Pfade in Unix-Pfade um (inkl. Clipboard).
    upath() {
        if [[ -z "${1:-}" ]]; then
            local clip
            # Robustere Clipboard-Abfrage via PowerShell
            clip=$(powershell.exe -NoProfile -Command "Get-Clipboard" 2>/dev/null | tr -d '\r\n')
            [[ -z "$clip" ]] && { echo "Clipboard leer."; return 1; }
            cygpath -u "$clip"
        else
            cygpath -u "$1"
        fi
    }
fi

# ──────────────────────────────────────────────────────────────
# 5. SYSTEM-STATUS & UTILS
# ──────────────────────────────────────────────────────────────

# @description Schneller Überblick über Systemressourcen.
health() {
    echo -e "${UI_ATTR_BOLD:-}--- SYSTEM HEALTH ---${UI_COL_RESET:-}"
    echo -e "Zeit:   $(date '+%Y-%m-%d %H:%M:%S')"
    echo -e "User:   $(whoami) @ $(hostname)"
    echo -ne "Uptime: " && { uptime -p 2>/dev/null || uptime; }

    if [[ "${PLATFORM:-}" == "linux" ]]; then
        echo -e "\n${UI_COL_CYAN:-}Speicherplatz (/):${UI_COL_RESET:-}"
        df -h / | tail -n 1
    elif [[ "${PLATFORM:-}" == "windows" ]]; then
        echo -e "\n${UI_COL_CYAN:-}Speicherplatz (C:):${UI_COL_RESET:-}"
        df -h /c 2>/dev/null | tail -n 1
    fi
}

# @description Erstellt Verzeichnisbaum und wechselt hinein.
mkd() {
    [[ -z "${1:-}" ]] && { echo "Nutzung: mkd <pfad>"; return 1; }
    mkdir -p "$1" && cd "$1" || return 1
}

true
